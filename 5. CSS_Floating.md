# Floating, Positioning
```뷰포트(Viewport)```와 관련하여 레이아웃(배치)을 다루기 위한 ```float```,```clear``` 및 ```position``` 속성 그리고 ```position``` 속성과 관련된 ```top```,```right```,```bottom```,```left```,```z-index``` 속성에 대해 서술한다.

# 1. 레이아웃 디자인 - 플로팅 레이아웃(float)
대표적인 레이아웃 테크닉인 플로팅(floating)과 포지셔닝(Positioning)을 알아보고, 모던 레이아웃인 플렉스박스(flexbox)와 그리드(Grid) 레이아웃에 대해 서술한다.

## 1.1 일반적인 레이아웃 흐름

![image](https://github.com/LDH9219/CSS_Summary/assets/62749021/5c4a7795-a7cb-4162-a039-a79ead7495ee)

<br>

```CSS가 미반영된 화면```에서 위에서부터 아래 방향으로 나열되는 것이 일반적인 레이아웃 흐름이라고 할 수 있다.    
위 HTML 코드 마크업상  ```<h1>```요소 다음에 ```<p>```요소의 순서대로 제목이 나오고 단락이 나오는 형태가 HTML 문서를 해석한 웹 브라우저가 화면에 그리는 방식이다.

## 1.2 플로팅(Floagting) 레이아웃
CSS ```float```속성은 특히 국내 실무 내에서 레이아웃 설계하는 과정에서 많이 사용하는 속성이다.    
복잡한 형태의 레이아웃을 구성하는데 필요한 핵심 속성으로 특정 요소를 ```떠 있게```, ```흐르도록```, ```부유하게 하도록``` 하는 속성이다.    
다시말해, ```float속성을 사용해 박스를 왼쪽 또는 오른쪽으로 부유시키는 레이아웃 기법```이다.    
    
여기서 '부유하다' 라는 의미는 요소가 ```기본적인 문서의 배치의 흐름에서 벗어나 요소의 모소리가 페이지의 왼쪽이나 오른쪽으로 이동하는 것을 말한다.    
이 플로팅 모델을 이용하면 문서의 흐름과 관계없이 화면 배치를 유연하게 할 수 있다.

![image](https://github.com/LDH9219/CSS_Summary/assets/62749021/40da754c-65ae-466b-8765-09157282fc15)

```css
.box {
    float: value;
}
```

**float 의 속성값**
이미지에 텍스트를 둘러싸게 만들려는 목표로 나온 기법이 ```floating``` 기법이다.
```float``` 속성을 사용할 요소는 ```position```속성의 ```absolute```값과 양립할 수 없다.
* ```left``` : 요소를 왼쪽 방향으로 부유하게 설정
* ```right``` : 요소를 오른쪽 방향으로 부유하게 설정
* ```none``` : 기본값(default), 요소를 띄우지 않는다.

### floating 모델 살펴보기
![image](https://github.com/LDH9219/CSS_Summary/assets/62749021/b1ef783a-48d1-408e-8a8b-c3723bf1c8bb)
![image](https://github.com/LDH9219/CSS_Summary/assets/62749021/f7defe38-b612-4ce1-8aea-ade05fde7827)
![image](https://github.com/LDH9219/CSS_Summary/assets/62749021/529b7a3b-8bd5-4350-bb0a-4245387c6b13)
![image](https://github.com/LDH9219/CSS_Summary/assets/62749021/ec69b56b-b42f-41b9-92ae-fa41d1c7cab7)

```
플로팅된 요소는 그 요소의 종류에 상관없이 블럭 박스가 된다.
인라인 요소인 링크(anchor)를 플로팅시키는 경우에 이 요소 특성은 블럭 박스로 변경되고 마치 div 인것 처럼 동작하게 된다.
대신 자신의 영역만을 가지고 있는 인라인 블럭박스처럼 렌더링 된다는 것이 특이한 점이다.
다시 말해, 플로팅된 요소는 display:inline-block;을 선언한 것과 동일해진다.
```

## clear - 플로팅 해제 기법
플로팅한 요소는 문서의 흐름상에서 벗어난 상태이기 때문에 레이아웃을 무너뜨리게 되는 현상을 보게 된다.    
이는 플롯을 사용하면 발생되는 현상이며 이러한 문제를 해결하기 위해서 ```float을 해제``` 해야 한다.    
여기서 "float을 해제한다"는 의미는 float이 적용된 요소를 해제하는 것이 아니라 ```clear 속성을 적용해 float의 영향을 받지 않도록 한다는 의미``` 이다.    

<br>

플롯을 해제하는 방법 중에 전 세계적으로 통용되는 이름(관용적인 기법의 이름)으로 ```clearfix```라는 방법이 있다.    
물론 ```clear```속성을 적용하기 보다 다른 방법으로도 플롯을 해제할 수는 있으나 ```float을 사용해 레이아웃을 잡다 보면 clear가 필요해지기 때문에 가급적 플롯된 요소의 부모 요소에 clearfix방법을 적용하는 것을 권장```하고 있다.    

<br>

다시 말해, ```float```이 적용된 자식 요소를 부모 요소가 감싸 안지 못하는 현상을 해결하기 위해서는 **대략적으로 6가지 방법**이 있는데 그중 대표적으로 많이 사용되는 방법이 ```clearfix```이다.    
```clearfix```방법은 무조건이라기 보다 필요에 의해서 사용하는 것이다.

```css
.clearfix{clear:value;}
```

**clear의 속성값**
* ```left``` : 왼쪽에 floating 된 요소를 지정 해제
* ```right``` : 오른쪽에 floating 된 요소를 지정 해제
* ```both``` : 왼쪽 오른쪽 모두 floating 된 요소를 지정 해제
* ```none``` : 기본값(default), floating 을 해제하지 않음

## 2 플롯을 해제하기 전과 해제 후 살펴보기

![image](https://github.com/LDH9219/CSS_Summary/assets/62749021/51182840-6391-40f7-a30c-288097650a3e)
![image](https://github.com/LDH9219/CSS_Summary/assets/62749021/4e880ab1-f956-4863-b094-4fef3cf8379d)

### 2.1 첫 번째 float 해제 방법
```css
.parent { float: left; }
```
플롯된 요소가 자식 요소일 경우에 부모요소는 자식 요소(문서 흐름에서 벗어남)를 감싸지 못하는 특징으로 인해 레이아웃이 무너진 형태처럼 보이게 된다.    
이는 플롯을 사용하게 되면 발생되는 현상이며 이 문제를 해결하기 위해서는 플롯의 영향을 받지 않도록 해야한다.    

<br>

다시 말해, 부모요소는 플롯된 자식요소를 포함하는 경우에 부모요소는 높이를 인지하지 못하게 된다.    
이 문제를 해결하는 방법 중에 하나가 ```부모(컨테이닝 요소)에게도 float 속성을 반영하는 방법```이다.    
이렇게 하면 부모 요소는 자식 요소의 높이를 인지하게 되지만 부모 요소도 float 된 요소가 되어 인라인 블럭의 특징을 가지고 되기 때문에 비주얼 디자인 레이아웃에 따라 상황에 맞도록 사용해야 한다.

### 2.2 두 번째 float 해제 방법
```css
.parent { display: inline-block; }
```
이 방법 역시 부모 요소에 적용하는데 ```display: inline-block;``` 속성을 사용하는 방법이 있다.    
부모 요소는 자식 요소의 높이를 인지하게 되지만 되지만 부모 요소에 정의된 인라인블럭 속성 특성 때문에 본인 영역만큼만 너비를 가지게 된다.

### 2.3 세 번째 float 해제 방법(권장되지 않음)
```css
.parent { overflow: hidden; }
```
이 속성 역시도 부모 요소에 적용해야 하며, 이 속성의 특징은 자식 요소가 부모 요소 박스보다 클 경우에 자식 요소 박스의 콘텐츠를 숨기고 보이지 않게 해주는 속성이다.    
```overflow: auto;```를 적용해도 되지만 자식 요소 박스의 너비가 부모 요소 박스의 너비보다 클 경우에 스크롤이 생기기 때문에 권장되지 않는다.    

<br>

overflow 특징대로 넘치는 것을 숨겨주는 속성인데, 여기선 다른 의미도 포함하고 있다.

넘치는 콘텐츠를 숨긴다는 의미는 부모 요소 박스가 그 자식 요소 콘텐츠를 숨긴다는 것이다.

그런데 부모 요소가 플롯된 자식 요소로 인해 높이를 인지하지 못하고 있는 상황에서 ```overflow: hidden;``` 속성을 적용하게 되면 부모 요소(컨테이닝 박스)는 넘치는 요소를 숨김 처리를 하려고 하기 때문에 자식 요소의 높이를 인지하기 위해 자동으로 높이값을 계산하게 된다.


### 2.4 네 번째 float 해제 방법(제일 권장되지 않음)
```css
<div class="box-group">
    <div class="box is-blue"></div>
    <div class="box is-yellow"></div>
    <div class="box is-green"></div>
    <div class="clear"></div>
</div>
```
이 방식은 과거(Legacy)에 널리 사용되던 방식(현재는 지양)으로 플롯된 요소의 마자막 요소(형제 레벨)로 빈 엘리먼트 작성하여 clear 속성을 적용하는 방법이다.

### 2.5 다섯 번째 float 해제 방법(제일 많이 사용됨)
```css
.parent:after {
     content: "";
     display:block;
     clear:both;
}
```
지금까지 소개한 방식 중 가장 널리 쓰이고 있는 테크닉으로 CSS의 가상(슈도클래스, 의사클래스) 클래스를 이용하는 방법이 있다.    
    
앞서 소개한 방법은 불필요한 의미없는 요소를 작성해야 했지만 이 방법은 CSS 를 통해 빈 가상 요소를 생성하여 float 을 해제하는 방법이다.    
    
CSS 의 가상 요소 중에 :after 를 이용한다.

### 2.6 여섯 번째 float 해제 방법
```css
.parent {
    /* For IE 6/7 only */
    *zoom: 1;
}
.parent:before,
.parent:after {
    content: "";
    display: table;
}
.parent:after {
    clear:both;
}
```
```micro clearfix``` 라는 이름의 테크닉이다.
CSS 연구전문가인 니콜라스 갤러거가 고안한 방법(micro clearfix hack)으로 처음 HTML5 보일러플레이트란 템플릿 엔진을 통해 소개되었다.

2011년에 고안되었지만 이후 부트스트랩(Ver.1~3)에서 이 방법을 사용하면서 널리 알려지게 되었다.

# 포지셔닝(Positioning)
앞서 학습한 플로팅(floating) 레이아웃은 일반적으로 큰 틀을 잡는데 사용할 수 있으나 세부적인 배치 작업을 할 때는 포지셔닝이란 테크닉을 사용할 필요가 있다. 포지셔닝이란 사전적 의미대로 위치를 잡을 때 사용하는 것으로 웹브라우저가 렌더링하는 기본 레이아웃 흐름(Normal Layout Flow)을 재정의하여 디테일한 위치를 지정하고자 할 때 사용한다.    
    
예를 들어, 페이지의 다른 부분 위에 떠있는 UI 요소를 나타내거나, 페이지의 스크롤과 상관없이 항상 브라우저 창의 동일한 위치에 자리한 UI 요소를 만들고자 하는 경우에 이용한다.

## 1. 포지셔닝(Positioning) 레이아웃 유형

* 정적(static) 위치 : 기본값
* 상대(relative) 위치
* 절대(absolute) 위치
* 고정(fixed) 위치
* 달라붙는(sticky) 위치 : IE 브라우저 미지원   **단, IE9 이상에서 자바스크립트를 이용하면 구현 가능함.**

```css
.element {
    position:relative;
    left:50px;
    top:10px;
    z-index:1;
}
```

### 1.1 static
```static``` 은 ```기본값(default)```으로, 문서의 흐름에 따라 순서대로 위치를 지정한다.    
이 값은 요소가 가지고 있는 기본(초기)값으로 위치를 지정하지 않을 때와 같고, 보통 static 을 사용할 일은 잘 없지만 ```position 의 오프셋 속성값을 무시하고자 하는 경우에 사용```될 수 있다.    
기본값이기 때문에 블록 레벨 요소는 문서 흐름에 포함된 사각 박스를 생성하고, 인라인 레벨 박스는 부모 요소의 흐름에 포함된 한 줄 이상의 라인 박스를 생성하며 ```top, bottom, left, right 속성값이 적용되지 않는다.```    

### 1.2 relative
```relative``` 는 사전적 의미대로 상대적으로 위치를 이동하게 된다.    
누구를 기준으로 상대 위치를 가지느냐 하는 것은 일반 흐름을 기준점으로 위치를 이동하게 된다. 

<br>

예를 들어 ```{left:20}``` 이면 요소 박스가 특정 거리만큼 위치 이동하게 되어 20픽셀이 요소의 왼쪽에 위치하게 된다.    
여기서 중요한 점은 HTML 의 기본 레이아웃 흐름에서는 요소가 플롯이 되었을 때 아래에 있는 요소 박스는 위(플롯이 적용된 요소)에 있는 박스가 없다고 인식하고 위로 올라가지만 ```position:relative;``` 를 사용하게 되면 이동하기 전의 요소가 자라잡고 있던 공간(박스의 원래 위치에 있던 공간)은 유지한 채 이동한다.    
즉, 기본 레이아웃 흐름을 그대로 유지하는 것이다. 

<br>

정리하면, ```offset``` 값을 설정하기 전인 요소 기존 공간은 그대로 유지(기존 공간(분신)을 두고 이동하는 특성)되기 때문에 그 공간 역시 이 요소가 차지하게 된다.    
그리고 별도의 ```offset``` 값을 지정하지 않으면 ```static``` 과 동일하게 동작힌다.    

### 1.3 absolute
해당 요소의 첫번째 부모 요소 위치(static 제외)에 따라 위치가 결정된다.    
이 요소 박스는 문서의 흐름에서 완전히 벗어나 버리기 때문에 요소가 일반적인 문서의 흐름에서 차지하던 공간은 그 요소가 가지고 있던 위치는 없는 것처럼 사라져 버린다.    
그리고 기존 요소가 있어야 할 위치와 상관없이 위치를 지정할 수 있기 때문에 절대 위치라고 한다.    
하지만 가장 가까운 상위 요소(부모요소) 중에 ```relative``` 나 ```absolute``` 가 적용된 요소를 기준으로 위치가 결정된다.    

<br>

즉, 본래 자신의 위치 혹은 부모 요소의 속성중 ```relative``` 나 ```absolute``` 가 선언된 요소를 기준으로 좌표 속성을 통해 이동시킬수 있다.

<br>

상위 요소가 없다면 위치는 ```html``` 이나 ```body``` 를 기준으로 설정된다. (브라우저마다 다름)
* absolute 와 float 의 차이점
>   float 의 경우, 설정된 요소 보다 마크업 순서상 먼저 작성된 요소들에게는 영향을 끼치지 않고 오직 float 이 적용된 요소보다 나중에 작성된 요소들에게만 영향을 끼치게 된다.    
반면 absolute 가 적용된 요소는 마크업 순서상 먼저 작성 되었던, 나중에 작성 되었던 상관 없이 모두 영향을 받게 된다.

### 1.4 fixed
해당 영역에 위치를 고정
```absolute``` 값으로 설정된 경우와 비슷하게 동작하지만 ```브라우저 화면(뷰포트)를 기준으로 위치를 이동```하게 된다.
```fixed``` 가 부여된 요소는 뷰포트에 상대적으로 위치가 지정되는데 이는 페이지가 스크롤되더라도 늘 같은 곳에 위치한다는 의미이다.

```relative```, ```absolute``` 와 마찬가지로 ```offset``` 값으로 제어가 가능하다. 따라서 화면이 스크롤되면서 화면전환이 일어나더라도 항상 같은 위치의 고정된 위치를 설정할 수 있다.

다시말해, ```상위(부모) 요소에 영향을 받지 않는다.```

### 1.5 top, right, bottom, left
위에서 학습한 CSS 속성과 함께 ```top```, ```right```, ```bottom```, ```left``` 을 설정하여 세부적인 위치 이동을 할 수 있다.    
    
다시 말해, ```position``` 속성 값은 ```top``` / ```bottom``` / ```left``` / ```right``` 값을 기준으로 위치 이동하는데 ```양수 값이면 박스 영역의 안쪽 뱡향으로 이동하고 음수 값이면 박스 영역의 바깥쪽 방향으로 이동```한다.

**양수값**
* ```left: 100px``` : 요소의 왼쪽을 기준으로 오른쪽으로 이동
* ```top: 100px``` : 요소의 위쪽을 기준으로 아래로 이동
* ```right: 100px``` : 요소의 오른쪽을 기준으로 왼쪽으로 이동
* ```bottom: 100px``` : 요소의 아래쪽을 기준으로 위쪽로 이동

**음수값**
* ```left: -100px``` : 요소의 왼쪽을 기준으로 왼쪽으로 이동
* ```top: -100px``` : 요소의 위쪽을 기준으로 위로 이동
* ```right: -100px``` : 요소의 오른쪽을 기준으로 오른쪽으로 이동
* ```bottom: -100px``` : 요소의 아래쪽을 기준으로 아래쪽으로 이동

<br>

포지션 속성을 사용해 박스를 위치 이동시킬 때 top 또는 bottom, left 또는 right 기준점을 설정한다.
    * 정리하면 위치 이동의 기준 축 설정은 사각형의 각 모서리가 된다.

    * 좌측 상단 (top, left)
    * 우측 상단 (top, right)
    * 좌측 하단 (bottom, left)
    * 우측 하단 (bottom, right)

이어서 이동 거리 설정은 양수, 0, 음수 설정이 가능하고, 각 설정에 따라 이동하는 방향은 박스를 그렸을 때, 양수는 박스 내부 방향으로 이동하게 됩니다. 반대로 음수는 박스 외부 방향으로 이동하게 된다.

그렇기 때문에 박스의 위치 이동 기준점에 따라 값은 양수 또는 음수 설정이 필요하게 된다.

### 1.6 z-index
```z-index``` 속성은 해당 요소에 대한 순차적인 위치(어떤 요소가 앞으로 나오고 뒤에 나오게 할지 배치 순서를 결정)를 지정하는 것이며, 숫자가 가장 크게 지정된 요소가 항상 제일 앞(위)쪽에 위치하게 된다.    
    
즉, ```z-index``` 는 요소의 순서를 제어하는 속성이다.    
    
여기서 순서라는 것은 상,우,하,좌의 2차원적 순서가 아닌 속성 이름에서도 알 수 있듯이 ```z축의 3차원적 순서```를 의미한다.    
    
결국 가장 위쪽에 위치한다는 말은 z축을 기준으로 겹침 상태에서의 가장 위를 의미하며, 숫자가 낮을 수록 아래로 배치되며 숫자가 높을 수록 위로 배치하게 된다.    
